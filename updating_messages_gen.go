// Code generated by telegram-apigen. DO NOT EDIT.

package telegram

import "encoding/json"

type EditMessageTextRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// New text of the message, 1-4096 characters after entities parsing
	Text string `json:"text"`

	// Optional. Mode for parsing entities in the message text. See formatting options
	// for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in message text, which can be
	// specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`

	// Optional. Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`

	// Optional. A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit text and game messages. On success, if the edited
// message is not an inline message, the edited Message is returned, otherwise True
// is returned.
func (b *Bot) EditMessageText(req *EditMessageTextRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageText", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageCaptionRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Optional. New caption of the message, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the message caption. See formatting
	// options for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit captions of messages. On success, if the edited message
// is not an inline message, the edited Message is returned, otherwise True is
// returned.
func (b *Bot) EditMessageCaption(req *EditMessageCaptionRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageCaption", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageMediaRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// A JSON-serialized object for a new media content of the message
	Media *InputMedia `json:"media"`

	// Optional. A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit animation, audio, document, photo, or video messages. If
// a message is part of a message album, then it can be edited only to an audio for
// audio albums, only to a document for document albums and to a photo or a video
// otherwise. When an inline message is edited, a new file can't be uploaded. Use a
// previously uploaded file via its file_id or specify a URL. On success, if the
// edited message was sent by the bot, the edited Message is returned, otherwise
// True is returned.
func (b *Bot) EditMessageMedia(req *EditMessageMediaRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageMedia", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageReplyMarkupRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Optional. A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit only the reply markup of messages. On success, if the
// edited message is not an inline message, the edited Message is returned,
// otherwise True is returned.
func (b *Bot) EditMessageReplyMarkup(req *EditMessageReplyMarkupRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageReplyMarkup", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type StopPollRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the original message with the poll
	MessageID int `json:"message_id"`

	// Optional. A JSON-serialized object for a new message inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to stop a poll which was sent by the bot. On success, the
// stopped Poll with the final results is returned.
func (b *Bot) StopPoll(req *StopPollRequest) (*Poll, error) {
	j, err := b.makeRequest("stopPoll", req)
	if err != nil {
		return nil, err
	}

	var resp Poll
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type DeleteMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the message to delete
	MessageID int `json:"message_id"`
}

// Use this method to delete a message, including service messages, with the
// following limitations:
// - A message can only be deleted if it was sent less than 48 hours ago.
// - A dice message in a private chat can only be deleted if it was sent more than
// 24 hours ago.
// - Bots can delete outgoing messages in private chats, groups, and supergroups.
// - Bots can delete incoming messages in private chats.
// - Bots granted can_post_messages permissions can delete outgoing messages in
// channels.
// - If the bot is an administrator of a group, it can delete any message there.
// - If the bot has can_delete_messages permission in a supergroup or a channel, it
// can delete any message there.
// Returns True on success.
func (b *Bot) DeleteMessage(req *DeleteMessageRequest) (json.RawMessage, error) {
	return b.makeRequest("deleteMessage", req)
}
