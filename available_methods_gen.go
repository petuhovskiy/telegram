// Code generated by telegram-apigen. DO NOT EDIT.

package telegram

import "encoding/json"

type GetMeRequest struct{}

// A simple method for testing your bot's auth token. Requires no parameters.
// Returns basic information about the bot in form of a User object.
func (b *Bot) GetMe(req *GetMeRequest) (*User, error) {
	j, err := b.makeRequest("getMe", req)
	if err != nil {
		return nil, err
	}

	var resp User
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type LogOutRequest struct{}

// Use this method to log out from the cloud Bot API server before launching the
// bot locally. You must log out the bot before running it locally, otherwise there
// is no guarantee that the bot will receive updates. After a successful call, you
// can immediately log in on a local server, but will not be able to log in back to
// the cloud Bot API server for 10 minutes. Returns True on success. Requires no
// parameters.
func (b *Bot) LogOut(req *LogOutRequest) (json.RawMessage, error) {
	return b.makeRequest("logOut", req)
}

type CloseRequest struct{}

// Use this method to close the bot instance before moving it from one local server
// to another. You need to delete the webhook before calling this method to ensure
// that the bot isn't launched again after server restart. The method will return
// error 429 in the first 10 minutes after the bot is launched. Returns True on
// success. Requires no parameters.
func (b *Bot) Close(req *CloseRequest) (json.RawMessage, error) {
	return b.makeRequest("close", req)
}

type SendMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`

	// Optional. Mode for parsing entities in the message text. See formatting options
	// for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in message text, which can be
	// specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`

	// Optional. Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send text messages. On success, the sent Message is
// returned.
func (b *Bot) SendMessage(req *SendMessageRequest) (*Message, error) {
	j, err := b.makeRequest("sendMessage", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type ForwardMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the chat where the original message was sent (or channel
	// username in the format @channelusername)
	FromChatID string `json:"from_chat_id"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Message identifier in the chat specified in from_chat_id
	MessageID int `json:"message_id"`
}

// Use this method to forward messages of any kind. On success, the sent Message is
// returned.
func (b *Bot) ForwardMessage(req *ForwardMessageRequest) (*Message, error) {
	j, err := b.makeRequest("forwardMessage", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type CopyMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the chat where the original message was sent (or channel
	// username in the format @channelusername)
	FromChatID string `json:"from_chat_id"`

	// Message identifier in the chat specified in from_chat_id
	MessageID int `json:"message_id"`

	// Optional. New caption for media, 0-1024 characters after entities parsing. If
	// not specified, the original caption is kept
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the new caption. See formatting options
	// for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the new caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to copy messages of any kind. The method is analogous to the
// method forwardMessages, but the copied message doesn't have a link to the
// original message. Returns the MessageId of the sent message on success.
func (b *Bot) CopyMessage(req *CopyMessageRequest) (*MessageId, error) {
	j, err := b.makeRequest("copyMessage", req)
	if err != nil {
		return nil, err
	}

	var resp MessageId
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendPhotoRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Photo to send. Pass a file_id as String to send a photo that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get
	// a photo from the Internet, or upload a new photo using multipart/form-data. The
	// photo must be at most 10 MB in size. The photo's width and height must not
	// exceed 10000 in total. Width and height ratio must be at most 20. More info on
	// Sending Files »
	Photo Fileable `json:"photo"`

	// Optional. Photo caption (may also be used when resending photos by file_id),
	// 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the photo caption. See formatting options
	// for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send photos. On success, the sent Message is returned.
func (b *Bot) SendPhoto(req *SendPhotoRequest) (*Message, error) {
	j, err := b.makeRequest("sendPhoto", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendAudioRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Audio file to send. Pass a file_id as String to send an audio file that exists
	// on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram
	// to get an audio file from the Internet, or upload a new one using
	// multipart/form-data. More info on Sending Files »
	Audio Fileable `json:"audio"`

	// Optional. Audio caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the audio caption. See formatting options
	// for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Duration of the audio in seconds
	Duration int `json:"duration,omitempty"`

	// Optional. Performer
	Performer string `json:"performer,omitempty"`

	// Optional. Track name
	Title string `json:"title,omitempty"`

	// Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for
	// the file is supported server-side. The thumbnail should be in JPEG format and
	// less than 200 kB in size. A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't
	// be reused and can be only uploaded as a new file, so you can pass
	// “attach://<file_attach_name>” if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More info on Sending Files »
	Thumb Fileable `json:"thumb,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send audio files, if you want Telegram clients to display
// them in the music player. Your audio must be in the .MP3 or .M4A format. On
// success, the sent Message is returned. Bots can currently send audio files of up
// to 50 MB in size, this limit may be changed in the future.
//
// For sending voice messages, use the sendVoice method instead.
func (b *Bot) SendAudio(req *SendAudioRequest) (*Message, error) {
	j, err := b.makeRequest("sendAudio", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendDocumentRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// File to send. Pass a file_id as String to send a file that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get
	// a file from the Internet, or upload a new one using multipart/form-data. More
	// info on Sending Files »
	Document Fileable `json:"document"`

	// Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for
	// the file is supported server-side. The thumbnail should be in JPEG format and
	// less than 200 kB in size. A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't
	// be reused and can be only uploaded as a new file, so you can pass
	// “attach://<file_attach_name>” if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More info on Sending Files »
	Thumb Fileable `json:"thumb,omitempty"`

	// Optional. Document caption (may also be used when resending documents by
	// file_id), 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the document caption. See formatting
	// options for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Disables automatic server-side content type detection for files
	// uploaded using multipart/form-data
	DisableContentTypeDetection bool `json:"disable_content_type_detection,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send general files. On success, the sent Message is returned.
// Bots can currently send files of any type of up to 50 MB in size, this limit may
// be changed in the future.
func (b *Bot) SendDocument(req *SendDocumentRequest) (*Message, error) {
	j, err := b.makeRequest("sendDocument", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendVideoRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Video to send. Pass a file_id as String to send a video that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get
	// a video from the Internet, or upload a new video using multipart/form-data. More
	// info on Sending Files »
	Video Fileable `json:"video"`

	// Optional. Duration of sent video in seconds
	Duration int `json:"duration,omitempty"`

	// Optional. Video width
	Width int `json:"width,omitempty"`

	// Optional. Video height
	Height int `json:"height,omitempty"`

	// Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for
	// the file is supported server-side. The thumbnail should be in JPEG format and
	// less than 200 kB in size. A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't
	// be reused and can be only uploaded as a new file, so you can pass
	// “attach://<file_attach_name>” if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More info on Sending Files »
	Thumb Fileable `json:"thumb,omitempty"`

	// Optional. Video caption (may also be used when resending videos by file_id),
	// 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the video caption. See formatting options
	// for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Pass True, if the uploaded video is suitable for streaming
	SupportsStreaming bool `json:"supports_streaming,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send video files, Telegram clients support mp4 videos (other
// formats may be sent as Document). On success, the sent Message is returned. Bots
// can currently send video files of up to 50 MB in size, this limit may be changed
// in the future.
func (b *Bot) SendVideo(req *SendVideoRequest) (*Message, error) {
	j, err := b.makeRequest("sendVideo", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendAnimationRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Animation to send. Pass a file_id as String to send an animation that exists on
	// the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to
	// get an animation from the Internet, or upload a new animation using
	// multipart/form-data. More info on Sending Files »
	Animation Fileable `json:"animation"`

	// Optional. Duration of sent animation in seconds
	Duration int `json:"duration,omitempty"`

	// Optional. Animation width
	Width int `json:"width,omitempty"`

	// Optional. Animation height
	Height int `json:"height,omitempty"`

	// Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for
	// the file is supported server-side. The thumbnail should be in JPEG format and
	// less than 200 kB in size. A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't
	// be reused and can be only uploaded as a new file, so you can pass
	// “attach://<file_attach_name>” if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More info on Sending Files »
	Thumb Fileable `json:"thumb,omitempty"`

	// Optional. Animation caption (may also be used when resending animation by
	// file_id), 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the animation caption. See formatting
	// options for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without
// sound). On success, the sent Message is returned. Bots can currently send
// animation files of up to 50 MB in size, this limit may be changed in the
// future.
func (b *Bot) SendAnimation(req *SendAnimationRequest) (*Message, error) {
	j, err := b.makeRequest("sendAnimation", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendVoiceRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Audio file to send. Pass a file_id as String to send a file that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get
	// a file from the Internet, or upload a new one using multipart/form-data. More
	// info on Sending Files »
	Voice Fileable `json:"voice"`

	// Optional. Voice message caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Optional. Mode for parsing entities in the voice message caption. See formatting
	// options for more details.
	ParseMode string `json:"parse_mode,omitempty"`

	// Optional. List of special entities that appear in the caption, which can be
	// specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Optional. Duration of the voice message in seconds
	Duration int `json:"duration,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send audio files, if you want Telegram clients to display the
// file as a playable voice message. For this to work, your audio must be in an
// .OGG file encoded with OPUS (other formats may be sent as Audio or Document). On
// success, the sent Message is returned. Bots can currently send voice messages of
// up to 50 MB in size, this limit may be changed in the future.
func (b *Bot) SendVoice(req *SendVoiceRequest) (*Message, error) {
	j, err := b.makeRequest("sendVoice", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendVideoNoteRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Video note to send. Pass a file_id as String to send a video note that exists on
	// the Telegram servers (recommended) or upload a new video using
	// multipart/form-data. More info on Sending Files ». Sending video notes by a URL
	// is currently unsupported
	VideoNote Fileable `json:"video_note"`

	// Optional. Duration of sent video in seconds
	Duration int `json:"duration,omitempty"`

	// Optional. Video width and height, i.e. diameter of the video message
	Length int `json:"length,omitempty"`

	// Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for
	// the file is supported server-side. The thumbnail should be in JPEG format and
	// less than 200 kB in size. A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't
	// be reused and can be only uploaded as a new file, so you can pass
	// “attach://<file_attach_name>” if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>. More info on Sending Files »
	Thumb Fileable `json:"thumb,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1
// minute long. Use this method to send video messages. On success, the sent
// Message is returned.
func (b *Bot) SendVideoNote(req *SendVideoNoteRequest) (*Message, error) {
	j, err := b.makeRequest("sendVideoNote", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendLocationRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Latitude of the location
	Latitude float64 `json:"latitude"`

	// Longitude of the location
	Longitude float64 `json:"longitude"`

	// Optional. The radius of uncertainty for the location, measured in meters;
	// 0-1500
	HorizontalAccuracy float64 `json:"horizontal_accuracy,omitempty"`

	// Optional. Period in seconds for which the location will be updated (see Live
	// Locations, should be between 60 and 86400.
	LivePeriod int `json:"live_period,omitempty"`

	// Optional. For live locations, a direction in which the user is moving, in
	// degrees. Must be between 1 and 360 if specified.
	Heading int `json:"heading,omitempty"`

	// Optional. For live locations, a maximum distance for proximity alerts about
	// approaching another chat member, in meters. Must be between 1 and 100000 if
	// specified.
	ProximityAlertRadius int `json:"proximity_alert_radius,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send point on the map. On success, the sent Message is
// returned.
func (b *Bot) SendLocation(req *SendLocationRequest) (*Message, error) {
	j, err := b.makeRequest("sendLocation", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type EditMessageLiveLocationRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message to edit
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Latitude of new location
	Latitude float64 `json:"latitude"`

	// Longitude of new location
	Longitude float64 `json:"longitude"`

	// Optional. The radius of uncertainty for the location, measured in meters;
	// 0-1500
	HorizontalAccuracy float64 `json:"horizontal_accuracy,omitempty"`

	// Optional. Direction in which the user is moving, in degrees. Must be between 1
	// and 360 if specified.
	Heading int `json:"heading,omitempty"`

	// Optional. Maximum distance for proximity alerts about approaching another chat
	// member, in meters. Must be between 1 and 100000 if specified.
	ProximityAlertRadius int `json:"proximity_alert_radius,omitempty"`

	// Optional. A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to edit live location messages. A location can be edited until
// its live_period expires or editing is explicitly disabled by a call to
// stopMessageLiveLocation. On success, if the edited message is not an inline
// message, the edited Message is returned, otherwise True is returned.
func (b *Bot) EditMessageLiveLocation(req *EditMessageLiveLocationRequest) (*Message, error) {
	j, err := b.makeRequest("editMessageLiveLocation", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type StopMessageLiveLocationRequest struct {
	// Optional. Required if inline_message_id is not specified. Unique identifier for
	// the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Optional. Required if inline_message_id is not specified. Identifier of the
	// message with live location to stop
	MessageID int `json:"message_id,omitempty"`

	// Optional. Required if chat_id and message_id are not specified. Identifier of
	// the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Optional. A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// Use this method to stop updating a live location message before live_period
// expires. On success, if the message was sent by the bot, the sent Message is
// returned, otherwise True is returned.
func (b *Bot) StopMessageLiveLocation(req *StopMessageLiveLocationRequest) (*Message, error) {
	j, err := b.makeRequest("stopMessageLiveLocation", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendVenueRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Latitude of the venue
	Latitude float64 `json:"latitude"`

	// Longitude of the venue
	Longitude float64 `json:"longitude"`

	// Name of the venue
	Title string `json:"title"`

	// Address of the venue
	Address string `json:"address"`

	// Optional. Foursquare identifier of the venue
	FoursquareID string `json:"foursquare_id,omitempty"`

	// Optional. Foursquare type of the venue, if known. (For example,
	// “arts_entertainment/default”, “arts_entertainment/aquarium” or
	// “food/icecream”.)
	FoursquareType string `json:"foursquare_type,omitempty"`

	// Optional. Google Places identifier of the venue
	GooglePlaceID string `json:"google_place_id,omitempty"`

	// Optional. Google Places type of the venue. (See supported types.)
	GooglePlaceType string `json:"google_place_type,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send information about a venue. On success, the sent Message
// is returned.
func (b *Bot) SendVenue(req *SendVenueRequest) (*Message, error) {
	j, err := b.makeRequest("sendVenue", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendContactRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Contact's phone number
	PhoneNumber string `json:"phone_number"`

	// Contact's first name
	FirstName string `json:"first_name"`

	// Optional. Contact's last name
	LastName string `json:"last_name,omitempty"`

	// Optional. Additional data about the contact in the form of a vCard, 0-2048
	// bytes
	Vcard string `json:"vcard,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove keyboard or to force a
	// reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send phone contacts. On success, the sent Message is
// returned.
func (b *Bot) SendContact(req *SendContactRequest) (*Message, error) {
	j, err := b.makeRequest("sendContact", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendPollRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Poll question, 1-300 characters
	Question string `json:"question"`

	// A JSON-serialized list of answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`

	// Optional. True, if the poll needs to be anonymous, defaults to True
	IsAnonymous bool `json:"is_anonymous,omitempty"`

	// Optional. Poll type, “quiz” or “regular”, defaults to “regular”
	Type string `json:"type,omitempty"`

	// Optional. True, if the poll allows multiple answers, ignored for polls in quiz
	// mode, defaults to False
	AllowsMultipleAnswers bool `json:"allows_multiple_answers,omitempty"`

	// Optional. 0-based identifier of the correct answer option, required for polls in
	// quiz mode
	CorrectOptionID int `json:"correct_option_id,omitempty"`

	// Optional. Text that is shown when a user chooses an incorrect answer or taps on
	// the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds
	// after entities parsing
	Explanation string `json:"explanation,omitempty"`

	// Optional. Mode for parsing entities in the explanation. See formatting options
	// for more details.
	ExplanationParseMode string `json:"explanation_parse_mode,omitempty"`

	// Optional. List of special entities that appear in the poll explanation, which
	// can be specified instead of parse_mode
	ExplanationEntities []MessageEntity `json:"explanation_entities,omitempty"`

	// Optional. Amount of time in seconds the poll will be active after creation,
	// 5-600. Can't be used together with close_date.
	OpenPeriod int `json:"open_period,omitempty"`

	// Optional. Point in time (Unix timestamp) when the poll will be automatically
	// closed. Must be at least 5 and no more than 600 seconds in the future. Can't be
	// used together with open_period.
	CloseDate int `json:"close_date,omitempty"`

	// Optional. Pass True, if the poll needs to be immediately closed. This can be
	// useful for poll preview.
	IsClosed bool `json:"is_closed,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send a native poll. On success, the sent Message is
// returned.
func (b *Bot) SendPoll(req *SendPollRequest) (*Message, error) {
	j, err := b.makeRequest("sendPoll", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendDiceRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Optional. Emoji on which the dice throw animation is based. Currently, must be
	// one of “”, “”, “”, “”, or “”. Dice can have values 1-6 for
	// “” and “”, values 1-5 for “” and “”, and values 1-64 for “”.
	// Defaults to “”
	Emoji string `json:"emoji,omitempty"`

	// Optional. Sends the message silently. Users will receive a notification with no
	// sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Optional. If the message is a reply, ID of the original message
	ReplyToMessageID int `json:"reply_to_message_id,omitempty"`

	// Optional. Pass True, if the message should be sent even if the specified
	// replied-to message is not found
	AllowSendingWithoutReply bool `json:"allow_sending_without_reply,omitempty"`

	// Optional. Additional interface options. A JSON-serialized object for an inline
	// keyboard, custom reply keyboard, instructions to remove reply keyboard or to
	// force a reply from the user.
	ReplyMarkup AnyKeyboard `json:"reply_markup,omitempty"`
}

// Use this method to send an animated emoji that will display a random value. On
// success, the sent Message is returned.
func (b *Bot) SendDice(req *SendDiceRequest) (*Message, error) {
	j, err := b.makeRequest("sendDice", req)
	if err != nil {
		return nil, err
	}

	var resp Message
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SendChatActionRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Type of action to broadcast. Choose one, depending on what the user is about to
	// receive: typing for text messages, upload_photo for photos, record_video or
	// upload_video for videos, record_voice or upload_voice for voice notes,
	// upload_document for general files, find_location for location data,
	// record_video_note or upload_video_note for video notes.
	Action string `json:"action"`
}

// Use this method when you need to tell the user that something is happening on
// the bot's side. The status is set for 5 seconds or less (when a message arrives
// from your bot, Telegram clients clear its typing status). Returns True on
// success.
//
//
// Example: The ImageBot needs some time to process a request and upload the image.
// Instead of sending a text message along the lines of “Retrieving image, please
// wait…”, the bot may use sendChatAction with action = upload_photo. The user
// will see a “sending photo” status for the bot.
//
//
// We only recommend using this method when a response from the bot will take a
// noticeable amount of time to arrive.
func (b *Bot) SendChatAction(req *SendChatActionRequest) (json.RawMessage, error) {
	return b.makeRequest("sendChatAction", req)
}

type GetUserProfilePhotosRequest struct {
	// Unique identifier of the target user
	UserID int `json:"user_id"`

	// Optional. Sequential number of the first photo to be returned. By default, all
	// photos are returned.
	Offset int `json:"offset,omitempty"`

	// Optional. Limits the number of photos to be retrieved. Values between 1-100 are
	// accepted. Defaults to 100.
	Limit int `json:"limit,omitempty"`
}

// Use this method to get a list of profile pictures for a user. Returns a
// UserProfilePhotos object.
func (b *Bot) GetUserProfilePhotos(req *GetUserProfilePhotosRequest) (*UserProfilePhotos, error) {
	j, err := b.makeRequest("getUserProfilePhotos", req)
	if err != nil {
		return nil, err
	}

	var resp UserProfilePhotos
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type GetFileRequest struct {
	// File identifier to get info about
	FileID string `json:"file_id"`
}

// Use this method to get basic info about a file and prepare it for downloading.
// For the moment, bots can download files of up to 20MB in size. On success, a
// File object is returned. The file can then be downloaded via the link
// https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken
// from the response. It is guaranteed that the link will be valid for at least 1
// hour. When the link expires, a new one can be requested by calling getFile
// again.
//
// Note: This function may not preserve the original file name and MIME type. You
// should save the file's MIME type and name (if available) when the File object is
// received.
func (b *Bot) GetFile(req *GetFileRequest) (*File, error) {
	j, err := b.makeRequest("getFile", req)
	if err != nil {
		return nil, err
	}

	var resp File
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type KickChatMemberRequest struct {
	// Unique identifier for the target group or username of the target supergroup or
	// channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int `json:"user_id"`

	// Optional. Date when the user will be unbanned, unix time. If user is banned for
	// more than 366 days or less than 30 seconds from the current time they are
	// considered to be banned forever. Applied for supergroups and channels only.
	UntilDate int `json:"until_date,omitempty"`
}

// Use this method to kick a user from a group, a supergroup or a channel. In the
// case of supergroups and channels, the user will not be able to return to the
// chat on their own using invite links, etc., unless unbanned first. The bot must
// be an administrator in the chat for this to work and must have the appropriate
// admin rights. Returns True on success.
func (b *Bot) KickChatMember(req *KickChatMemberRequest) (json.RawMessage, error) {
	return b.makeRequest("kickChatMember", req)
}

type UnbanChatMemberRequest struct {
	// Unique identifier for the target group or username of the target supergroup or
	// channel (in the format @username)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int `json:"user_id"`

	// Optional. Do nothing if the user is not banned
	OnlyIfBanned bool `json:"only_if_banned,omitempty"`
}

// Use this method to unban a previously kicked user in a supergroup or channel.
// The user will not return to the group or channel automatically, but will be able
// to join via link, etc. The bot must be an administrator for this to work. By
// default, this method guarantees that after the call the user is not a member of
// the chat, but will be able to join it. So if the user is a member of the chat
// they will also be removed from the chat. If you don't want this, use the
// parameter only_if_banned. Returns True on success.
func (b *Bot) UnbanChatMember(req *UnbanChatMemberRequest) (json.RawMessage, error) {
	return b.makeRequest("unbanChatMember", req)
}

type RestrictChatMemberRequest struct {
	// Unique identifier for the target chat or username of the target supergroup (in
	// the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int `json:"user_id"`

	// A JSON-serialized object for new user permissions
	Permissions *ChatPermissions `json:"permissions"`

	// Optional. Date when restrictions will be lifted for the user, unix time. If user
	// is restricted for more than 366 days or less than 30 seconds from the current
	// time, they are considered to be restricted forever
	UntilDate int `json:"until_date,omitempty"`
}

// Use this method to restrict a user in a supergroup. The bot must be an
// administrator in the supergroup for this to work and must have the appropriate
// admin rights. Pass True for all permissions to lift restrictions from a user.
// Returns True on success.
func (b *Bot) RestrictChatMember(req *RestrictChatMemberRequest) (json.RawMessage, error) {
	return b.makeRequest("restrictChatMember", req)
}

type PromoteChatMemberRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int `json:"user_id"`

	// Optional. Pass True, if the administrator's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous,omitempty"`

	// Optional. Pass True, if the administrator can change chat title, photo and other
	// settings
	CanChangeInfo bool `json:"can_change_info,omitempty"`

	// Optional. Pass True, if the administrator can create channel posts, channels
	// only
	CanPostMessages bool `json:"can_post_messages,omitempty"`

	// Optional. Pass True, if the administrator can edit messages of other users and
	// can pin messages, channels only
	CanEditMessages bool `json:"can_edit_messages,omitempty"`

	// Optional. Pass True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages,omitempty"`

	// Optional. Pass True, if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users,omitempty"`

	// Optional. Pass True, if the administrator can restrict, ban or unban chat
	// members
	CanRestrictMembers bool `json:"can_restrict_members,omitempty"`

	// Optional. Pass True, if the administrator can pin messages, supergroups only
	CanPinMessages bool `json:"can_pin_messages,omitempty"`

	// Optional. Pass True, if the administrator can add new administrators with a
	// subset of their own privileges or demote administrators that he has promoted,
	// directly or indirectly (promoted by administrators that were appointed by him)
	CanPromoteMembers bool `json:"can_promote_members,omitempty"`
}

// Use this method to promote or demote a user in a supergroup or a channel. The
// bot must be an administrator in the chat for this to work and must have the
// appropriate admin rights. Pass False for all boolean parameters to demote a
// user. Returns True on success.
func (b *Bot) PromoteChatMember(req *PromoteChatMemberRequest) (json.RawMessage, error) {
	return b.makeRequest("promoteChatMember", req)
}

type SetChatAdministratorCustomTitleRequest struct {
	// Unique identifier for the target chat or username of the target supergroup (in
	// the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int `json:"user_id"`

	// New custom title for the administrator; 0-16 characters, emoji are not allowed
	CustomTitle string `json:"custom_title"`
}

// Use this method to set a custom title for an administrator in a supergroup
// promoted by the bot. Returns True on success.
func (b *Bot) SetChatAdministratorCustomTitle(req *SetChatAdministratorCustomTitleRequest) (json.RawMessage, error) {
	return b.makeRequest("setChatAdministratorCustomTitle", req)
}

type SetChatPermissionsRequest struct {
	// Unique identifier for the target chat or username of the target supergroup (in
	// the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// New default chat permissions
	Permissions *ChatPermissions `json:"permissions"`
}

// Use this method to set default chat permissions for all members. The bot must be
// an administrator in the group or a supergroup for this to work and must have the
// can_restrict_members admin rights. Returns True on success.
func (b *Bot) SetChatPermissions(req *SetChatPermissionsRequest) (json.RawMessage, error) {
	return b.makeRequest("setChatPermissions", req)
}

type ExportChatInviteLinkRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method to generate a new invite link for a chat; any previously
// generated link is revoked. The bot must be an administrator in the chat for this
// to work and must have the appropriate admin rights. Returns the new invite link
// as String on success.
//
//
// Note: Each administrator in a chat generates their own invite links. Bots can't
// use invite links generated by other administrators. If you want your bot to work
// with invite links, it will need to generate its own link using
// exportChatInviteLink — after this the link will become available to the bot
// via the getChat method. If your bot needs to generate a new invite link
// replacing its previous one, use exportChatInviteLink again.
//
func (b *Bot) ExportChatInviteLink(req *ExportChatInviteLinkRequest) (json.RawMessage, error) {
	return b.makeRequest("exportChatInviteLink", req)
}

type SetChatPhotoRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// New chat photo, uploaded using multipart/form-data
	Photo *InputFile `json:"photo"`
}

// Use this method to set a new profile photo for the chat. Photos can't be changed
// for private chats. The bot must be an administrator in the chat for this to work
// and must have the appropriate admin rights. Returns True on success.
func (b *Bot) SetChatPhoto(req *SetChatPhotoRequest) (json.RawMessage, error) {
	return b.makeRequest("setChatPhoto", req)
}

type DeleteChatPhotoRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method to delete a chat photo. Photos can't be changed for private
// chats. The bot must be an administrator in the chat for this to work and must
// have the appropriate admin rights. Returns True on success.
func (b *Bot) DeleteChatPhoto(req *DeleteChatPhotoRequest) (json.RawMessage, error) {
	return b.makeRequest("deleteChatPhoto", req)
}

type SetChatTitleRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// New chat title, 1-255 characters
	Title string `json:"title"`
}

// Use this method to change the title of a chat. Titles can't be changed for
// private chats. The bot must be an administrator in the chat for this to work and
// must have the appropriate admin rights. Returns True on success.
func (b *Bot) SetChatTitle(req *SetChatTitleRequest) (json.RawMessage, error) {
	return b.makeRequest("setChatTitle", req)
}

type SetChatDescriptionRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Optional. New chat description, 0-255 characters
	Description string `json:"description,omitempty"`
}

// Use this method to change the description of a group, a supergroup or a channel.
// The bot must be an administrator in the chat for this to work and must have the
// appropriate admin rights. Returns True on success.
func (b *Bot) SetChatDescription(req *SetChatDescriptionRequest) (json.RawMessage, error) {
	return b.makeRequest("setChatDescription", req)
}

type PinChatMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of a message to pin
	MessageID int `json:"message_id"`

	// Optional. Pass True, if it is not necessary to send a notification to all chat
	// members about the new pinned message. Notifications are always disabled in
	// channels and private chats.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// Use this method to add a message to the list of pinned messages in a chat. If
// the chat is not a private chat, the bot must be an administrator in the chat for
// this to work and must have the 'can_pin_messages' admin right in a supergroup or
// 'can_edit_messages' admin right in a channel. Returns True on success.
func (b *Bot) PinChatMessage(req *PinChatMessageRequest) (json.RawMessage, error) {
	return b.makeRequest("pinChatMessage", req)
}

type UnpinChatMessageRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`

	// Optional. Identifier of a message to unpin. If not specified, the most recent
	// pinned message (by sending date) will be unpinned.
	MessageID int `json:"message_id,omitempty"`
}

// Use this method to remove a message from the list of pinned messages in a chat.
// If the chat is not a private chat, the bot must be an administrator in the chat
// for this to work and must have the 'can_pin_messages' admin right in a
// supergroup or 'can_edit_messages' admin right in a channel. Returns True on
// success.
func (b *Bot) UnpinChatMessage(req *UnpinChatMessageRequest) (json.RawMessage, error) {
	return b.makeRequest("unpinChatMessage", req)
}

type UnpinAllChatMessagesRequest struct {
	// Unique identifier for the target chat or username of the target channel (in the
	// format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method to clear the list of pinned messages in a chat. If the chat is
// not a private chat, the bot must be an administrator in the chat for this to
// work and must have the 'can_pin_messages' admin right in a supergroup or
// 'can_edit_messages' admin right in a channel. Returns True on success.
func (b *Bot) UnpinAllChatMessages(req *UnpinAllChatMessagesRequest) (json.RawMessage, error) {
	return b.makeRequest("unpinAllChatMessages", req)
}

type LeaveChatRequest struct {
	// Unique identifier for the target chat or username of the target supergroup or
	// channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method for your bot to leave a group, supergroup or channel. Returns
// True on success.
func (b *Bot) LeaveChat(req *LeaveChatRequest) (json.RawMessage, error) {
	return b.makeRequest("leaveChat", req)
}

type GetChatRequest struct {
	// Unique identifier for the target chat or username of the target supergroup or
	// channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method to get up to date information about the chat (current name of
// the user for one-on-one conversations, current username of a user, group or
// channel, etc.). Returns a Chat object on success.
func (b *Bot) GetChat(req *GetChatRequest) (*Chat, error) {
	j, err := b.makeRequest("getChat", req)
	if err != nil {
		return nil, err
	}

	var resp Chat
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type GetChatAdministratorsRequest struct {
	// Unique identifier for the target chat or username of the target supergroup or
	// channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method to get a list of administrators in a chat. On success, returns
// an Array of ChatMember objects that contains information about all chat
// administrators except other bots. If the chat is a group or a supergroup and no
// administrators were appointed, only the creator will be returned.
func (b *Bot) GetChatAdministrators(req *GetChatAdministratorsRequest) (*ChatMember, error) {
	j, err := b.makeRequest("getChatAdministrators", req)
	if err != nil {
		return nil, err
	}

	var resp ChatMember
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type GetChatMembersCountRequest struct {
	// Unique identifier for the target chat or username of the target supergroup or
	// channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// Use this method to get the number of members in a chat. Returns Int on success.
func (b *Bot) GetChatMembersCount(req *GetChatMembersCountRequest) (json.RawMessage, error) {
	return b.makeRequest("getChatMembersCount", req)
}

type GetChatMemberRequest struct {
	// Unique identifier for the target chat or username of the target supergroup or
	// channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int `json:"user_id"`
}

// Use this method to get information about a member of a chat. Returns a
// ChatMember object on success.
func (b *Bot) GetChatMember(req *GetChatMemberRequest) (*ChatMember, error) {
	j, err := b.makeRequest("getChatMember", req)
	if err != nil {
		return nil, err
	}

	var resp ChatMember
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SetChatStickerSetRequest struct {
	// Unique identifier for the target chat or username of the target supergroup (in
	// the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Name of the sticker set to be set as the group sticker set
	StickerSetName string `json:"sticker_set_name"`
}

// Use this method to set a new group sticker set for a supergroup. The bot must be
// an administrator in the chat for this to work and must have the appropriate
// admin rights. Use the field can_set_sticker_set optionally returned in getChat
// requests to check if the bot can use this method. Returns True on success.
func (b *Bot) SetChatStickerSet(req *SetChatStickerSetRequest) (json.RawMessage, error) {
	return b.makeRequest("setChatStickerSet", req)
}

type DeleteChatStickerSetRequest struct {
	// Unique identifier for the target chat or username of the target supergroup (in
	// the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// Use this method to delete a group sticker set from a supergroup. The bot must be
// an administrator in the chat for this to work and must have the appropriate
// admin rights. Use the field can_set_sticker_set optionally returned in getChat
// requests to check if the bot can use this method. Returns True on success.
func (b *Bot) DeleteChatStickerSet(req *DeleteChatStickerSetRequest) (json.RawMessage, error) {
	return b.makeRequest("deleteChatStickerSet", req)
}

type AnswerCallbackQueryRequest struct {
	// Unique identifier for the query to be answered
	CallbackQueryID string `json:"callback_query_id"`

	// Optional. Text of the notification. If not specified, nothing will be shown to
	// the user, 0-200 characters
	Text string `json:"text,omitempty"`

	// Optional. If true, an alert will be shown by the client instead of a
	// notification at the top of the chat screen. Defaults to false.
	ShowAlert bool `json:"show_alert,omitempty"`

	// Optional. URL that will be opened by the user's client. If you have created a
	// Game and accepted the conditions via @Botfather, specify the URL that opens your
	// game — note that this will only work if the query comes from a callback_game
	// button.
	//
	// Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot
	// with a parameter.
	URL string `json:"url,omitempty"`

	// Optional. The maximum amount of time in seconds that the result of the callback
	// query may be cached client-side. Telegram apps will support caching starting in
	// version 3.14. Defaults to 0.
	CacheTime int `json:"cache_time,omitempty"`
}

// Use this method to send answers to callback queries sent from inline keyboards.
// The answer will be displayed to the user as a notification at the top of the
// chat screen or as an alert. On success, True is returned.
//
//
// Alternatively, the user can be redirected to the specified Game URL. For this
// option to work, you must first create a game for your bot via @Botfather and
// accept the terms. Otherwise, you may use links like t.me/your_bot?start=XXXX
// that open your bot with a parameter.
//
func (b *Bot) AnswerCallbackQuery(req *AnswerCallbackQueryRequest) (json.RawMessage, error) {
	return b.makeRequest("answerCallbackQuery", req)
}

type SetMyCommandsRequest struct {
	// A JSON-serialized list of bot commands to be set as the list of the bot's
	// commands. At most 100 commands can be specified.
	Commands []BotCommand `json:"commands"`
}

// Use this method to change the list of the bot's commands. Returns True on
// success.
func (b *Bot) SetMyCommands(req *SetMyCommandsRequest) (json.RawMessage, error) {
	return b.makeRequest("setMyCommands", req)
}

type GetMyCommandsRequest struct{}

// Use this method to get the current list of the bot's commands. Requires no
// parameters. Returns Array of BotCommand on success.
func (b *Bot) GetMyCommands(req *GetMyCommandsRequest) (*BotCommand, error) {
	j, err := b.makeRequest("getMyCommands", req)
	if err != nil {
		return nil, err
	}

	var resp BotCommand
	err = json.Unmarshal(j, &resp)
	return &resp, err
}
