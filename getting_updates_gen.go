// Code generated by telegram-apigen. DO NOT EDIT.

package telegram

import "encoding/json"

// This object represents an incoming update.
// At most one of the optional parameters can be present in any given update.
type Update struct {
	// The update's unique identifier. Update identifiers start from a certain positive
	// number and increase sequentially. This ID becomes especially handy if you're
	// using Webhooks, since it allows you to ignore repeated updates or to restore the
	// correct update sequence, should they get out of order. If there are no new
	// updates for at least a week, then identifier of the next update will be chosen
	// randomly instead of sequentially.
	UpdateID int `json:"update_id"`

	// Optional. New incoming message of any kind — text, photo, sticker, etc.
	Message *Message `json:"message,omitempty"`

	// Optional. New version of a message that is known to the bot and was edited
	EditedMessage *Message `json:"edited_message,omitempty"`

	// Optional. New incoming channel post of any kind — text, photo, sticker, etc.
	ChannelPost *Message `json:"channel_post,omitempty"`

	// Optional. New version of a channel post that is known to the bot and was edited
	EditedChannelPost *Message `json:"edited_channel_post,omitempty"`

	// Optional. New incoming inline query
	InlineQuery *InlineQuery `json:"inline_query,omitempty"`

	// Optional. The result of an inline query that was chosen by a user and sent to
	// their chat partner. Please see our documentation on the feedback collecting for
	// details on how to enable these updates for your bot.
	ChosenInlineResult *ChosenInlineResult `json:"chosen_inline_result,omitempty"`

	// Optional. New incoming callback query
	CallbackQuery *CallbackQuery `json:"callback_query,omitempty"`

	// Optional. New incoming shipping query. Only for invoices with flexible price
	ShippingQuery *ShippingQuery `json:"shipping_query,omitempty"`

	// Optional. New incoming pre-checkout query. Contains full information about
	// checkout
	PreCheckoutQuery *PreCheckoutQuery `json:"pre_checkout_query,omitempty"`

	// Optional. New poll state. Bots receive only updates about stopped polls and
	// polls, which are sent by the bot
	Poll *Poll `json:"poll,omitempty"`

	// Optional. A user changed their answer in a non-anonymous poll. Bots receive new
	// votes only in polls that were sent by the bot itself.
	PollAnswer *PollAnswer `json:"poll_answer,omitempty"`
}

type GetUpdatesRequest struct {
	// Optional. Identifier of the first update to be returned. Must be greater by one
	// than the highest among the identifiers of previously received updates. By
	// default, updates starting with the earliest unconfirmed update are returned. An
	// update is considered confirmed as soon as getUpdates is called with an offset
	// higher than its update_id. The negative offset can be specified to retrieve
	// updates starting from -offset update from the end of the updates queue. All
	// previous updates will forgotten.
	Offset int `json:"offset,omitempty"`

	// Optional. Limits the number of updates to be retrieved. Values between 1-100 are
	// accepted. Defaults to 100.
	Limit int `json:"limit,omitempty"`

	// Optional. Timeout in seconds for long polling. Defaults to 0, i.e. usual short
	// polling. Should be positive, short polling should be used for testing purposes
	// only.
	Timeout int `json:"timeout,omitempty"`

	// Optional. A JSON-serialized list of the update types you want your bot to
	// receive. For example, specify [“message”, “edited_channel_post”,
	// “callback_query”] to only receive updates of these types. See Update for a
	// complete list of available update types. Specify an empty list to receive all
	// updates regardless of type (default). If not specified, the previous setting
	// will be used.
	//
	// Please note that this parameter doesn't affect updates created before the call
	// to the getUpdates, so unwanted updates may be received for a short period of
	// time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
}

// Use this method to receive incoming updates using long polling (wiki). An Array
// of Update objects is returned.
//
//
// Notes
// 1. This method will not work if an outgoing webhook is set up.
// 2. In order to avoid getting duplicate updates, recalculate offset after each
// server response.
//
func (b *Bot) GetUpdates(req *GetUpdatesRequest) (*[]Update, error) {
	j, err := b.makeRequest("getUpdates", req)
	if err != nil {
		return nil, err
	}

	var resp []Update
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

type SetWebhookRequest struct {
	// HTTPS url to send updates to. Use an empty string to remove webhook integration
	URL string `json:"url"`

	// Optional. Upload your public key certificate so that the root certificate in use
	// can be checked. See our self-signed guide for details.
	Certificate *InputFile `json:"certificate,omitempty"`

	// Optional. The fixed IP address which will be used to send webhook requests
	// instead of the IP address resolved through DNS
	IpAddress string `json:"ip_address,omitempty"`

	// Optional. Maximum allowed number of simultaneous HTTPS connections to the
	// webhook for update delivery, 1-100. Defaults to 40. Use lower values to limit
	// the load on your bot's server, and higher values to increase your bot's
	// throughput.
	MaxConnections int `json:"max_connections,omitempty"`

	// Optional. A JSON-serialized list of the update types you want your bot to
	// receive. For example, specify [“message”, “edited_channel_post”,
	// “callback_query”] to only receive updates of these types. See Update for a
	// complete list of available update types. Specify an empty list to receive all
	// updates regardless of type (default). If not specified, the previous setting
	// will be used.
	// Please note that this parameter doesn't affect updates created before the call
	// to the setWebhook, so unwanted updates may be received for a short period of
	// time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`

	// Optional. Pass True to drop all pending updates
	DropPendingUpdates bool `json:"drop_pending_updates,omitempty"`
}

// Use this method to specify a url and receive incoming updates via an outgoing
// webhook. Whenever there is an update for the bot, we will send an HTTPS POST
// request to the specified url, containing a JSON-serialized Update. In case of an
// unsuccessful request, we will give up after a reasonable amount of attempts.
// Returns True on success.
//
// If you'd like to make sure that the Webhook request comes from Telegram, we
// recommend using a secret path in the URL, e.g. https://www.example.com/<token>.
// Since nobody else knows your bot's token, you can be pretty sure it's us.
//
//
// Notes
// 1. You will not be able to receive updates using getUpdates for as long as an
// outgoing webhook is set up.
// 2. To use a self-signed certificate, you need to upload your public key
// certificate using certificate parameter. Please upload as InputFile, sending a
// String will not work.
// 3. Ports currently supported for Webhooks: 443, 80, 88, 8443.
// NEW! If you're having any trouble setting up webhooks, please check out this
// amazing guide to Webhooks.
//
func (b *Bot) SetWebhook(req *SetWebhookRequest) (json.RawMessage, error) {
	return b.makeRequest("setWebhook", req)
}

type DeleteWebhookRequest struct {
	// Optional. Pass True to drop all pending updates
	DropPendingUpdates bool `json:"drop_pending_updates,omitempty"`
}

// Use this method to remove webhook integration if you decide to switch back to
// getUpdates. Returns True on success.
func (b *Bot) DeleteWebhook(req *DeleteWebhookRequest) (json.RawMessage, error) {
	return b.makeRequest("deleteWebhook", req)
}

type GetWebhookInfoRequest struct{}

// Use this method to get current webhook status. Requires no parameters. On
// success, returns a WebhookInfo object. If the bot is using getUpdates, will
// return an object with the url field empty.
func (b *Bot) GetWebhookInfo(req *GetWebhookInfoRequest) (*WebhookInfo, error) {
	j, err := b.makeRequest("getWebhookInfo", req)
	if err != nil {
		return nil, err
	}

	var resp WebhookInfo
	err = json.Unmarshal(j, &resp)
	return &resp, err
}

// Contains information about the current status of a webhook.
type WebhookInfo struct {
	// Webhook URL, may be empty if webhook is not set up
	URL string `json:"url"`

	// True, if a custom certificate was provided for webhook certificate checks
	HasCustomCertificate bool `json:"has_custom_certificate"`

	// Number of updates awaiting delivery
	PendingUpdateCount int `json:"pending_update_count"`

	// Optional. Currently used webhook IP address
	IpAddress string `json:"ip_address,omitempty"`

	// Optional. Unix time for the most recent error that happened when trying to
	// deliver an update via webhook
	LastErrorDate int `json:"last_error_date,omitempty"`

	// Optional. Error message in human-readable format for the most recent error that
	// happened when trying to deliver an update via webhook
	LastErrorMessage string `json:"last_error_message,omitempty"`

	// Optional. Maximum allowed number of simultaneous HTTPS connections to the
	// webhook for update delivery
	MaxConnections int `json:"max_connections,omitempty"`

	// Optional. A list of update types the bot is subscribed to. Defaults to all
	// update types
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
}
